import AuthHttpClient from "../http/AuthHttpClient";
import Util from "../Util";
import {maxDecimals, KeyLevel} from "../constants";

/**
 * Member object. Allows member-wide actions. Some calls return a promise, and some return
 * objects
 *
 */
export default class TransferTokenBuilder {

    /**
     * Represents a Builder for a transfer token.
     *
     * @constructor
     * @param {string} env - The environment to use for this member
     * @param {string} memberId - The id of this memberId
     * @param {object} cryptoEngine - the cryptoEngine to use for signing and key storage
     * @param {function} globalRpcErrorCallback - callback to invoke on any cross-cutting RPC
     * call error. For example: SDK version mismatch
     */
    constructor(client, member, amount, currency) {
        this._client = client;
        this._member = member;

        this._payload = {
            version: transferTokenVersion,
            nonce: Util.generateNonce(),
            from: {
                id: member.memberId,
            },
            transfer: {
                currency,
                lifetimeAmount: amount.toString(),
                instructions: {
                    source: null,
                    destinations: [],
                },
                redeemer: {},
                attachments: [],
            },
        };
    }

    setAccountId(accountId) {
        this._payload.transfer.instructions.source = {
            account: {
                token: {
                    memberId: this._member.memberId,
                    accountId,
                },
            }
        };
    }

    setBankAuthorization(bankAuthorization) {
        this._payload.transfer.instructions.source = {
            account: {
                tokenAuthorization: {
                    bankAuthorization,
                },
            }
        };
    }

    setExpiresAtMs(expiresAtMs) {
        this._payload.expiresAtMs = expiresAtMs;
    }

    setEffectiveAtMs(effectiveAtMs) {
        this._payload.effectiveAtMs = effectiveAtMs;
    }

    setChargeAmount(chargeAmount) {
        this._payload.transfer.amount = chargeAmount;

    setDescription(description) {
        this._payload.description = description;
    }

    addDestination(endpoint) {
        this._payload.transfer.instructions.destinations.push(endpoint);
    }

    setRedeemerUsername(redeemerUsername) {
        this._payload.transfer.redeemer.username = redeemerUsername;
    }

    setRedeemerMemberId(redeemerMemberId) {
        this._payload.transfer.redeemer.memberId = redeemerMemberId;
    }

    addAttachment(attachment) {
        this._payload.transfer.attachments.push(attachment);
    }

    async execute() {
        return Util.callAsync(this.execute, async () => {
            if (!this._payload.transfer.instructions.source.account.token
                && !this._payload.transfer.instructions.source.account.token) {
                throw new Error('No source on token');
            }
            if (!this._payload.transfer.redeemer.username
                && !this._payload.transfer.redeemer.memberId) {
                throw new Error('No redeemer on token');
            }

            const res = await this._client.createTransferToken(this._payload);
            return res.data.token;
        });
    }
}
