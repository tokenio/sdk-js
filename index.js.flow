// @flow
declare export class TokenIO {
    Crypto: any;
    BrowserCryptoEngine: any;
    ManualCryptoEngine: any;
    MemoryCryptoEngine: any;
    UnsecuredFileCryptoEngine: any;
    Util: any;
    TokenRequest: any;
    KeyLevel: {LOW?: string, PRIVILEGED?: string, STANDARD?: string};

    constructor(options: {
        developerKey?: string,
        env?: string,
        globalRpcErrorCallback?: ({message: string, name: string}) => void,
        keyDir?: string,
        loggingEnabled?: boolean,
    }): void;

    static enableIframePassthrough(env: string): void;

    static disableIframePassthrough(): void;

    aliasExists(alias: Alias): Promise<boolean>;

    createBusinessMember(alias: ?Alias, CryptoEngine: any): Promise<Member>;

    createMember(alias: ?Alias, CryptoEngine: any, memberType?: string): Promise<Member>;

    generateTokenRequestUrl(requestId: string, state?: string, csrfToken?: string): string;

    getBanks(options?: {
        country?: string,
        ids?: Array<string>,
        page?: number,
        perPage?: number,
        provider?: string,
        search?: string,
    }): Promise<{banks: ?Array<Bank>, paging: Paging}>;

    getMember(CryptoEngine: any, memberId?: string): Member;

    getTokenId(tokenRequestId: string): Promise<?string>;

    notifyAddKey(alias: Alias, keyName: string, key: Key, level: string, expiresMs: string): Promise<?string>;

    notifyLinkAccounts(alias: Alias, bankAuthorization: any): Promise<?string>;

    notifyLinkAccountsAndAddKey(alias: Alias, bankAuthorization: string, keyName: string, key: Key, level: string): Promise<?string>;

    notifyPaymentRequest(tokenPayload: TokenPayload): Promise<?string>;

    parseTokenRequestCallbackUrl(callbackUrl: string, csrfToken?: string): Promise<{innerState: string, tokenId: string}>;

    provisionDevice(alias: Alias, CryptoEngine: any): Promise<{keys: Array<Key>, memberId: string}>;

    provisionDeviceLow(alias: Alias, CryptoEngine: any, expirationMs?: number): Promise<{keys: Array<Key>, memberId: string}>;

    resolveAlias(alias: Alias): Promise<?TokenMember>;

    retrieveTokenRequest(requestId: string): Promise<?any>;
}

declare class Member {
    constructor(options: {
        env: string,
        memberId: ?string,
        cryptoEngine: any,
        developerKey: ?string,
        globalRpcErrorCallback: ?({message: string, name: string}) => void,
        loggingEnabled: ?boolean,
    }): void;

    addAddress(name: string, address: Address): Promise<?AddressRecord>;

    addAlias(alias: Alias): Promise<void>;

    addAliases(aliases: Array<Alias>): Promise<void>;

    aliases(): Promise<?Array<Alias>>;

    approveKey(key: Key): Promise<void>;

    approveKeys(keys: Array<Key>): Promise<void>;

    cancelToken(token: Token): Promise<TokenOperationResult>;

    clearAccessToken(): void;

    createAccessToken(alias: Alias, resources: Array<Resource>): Promise<?Token>;

    createAccessTokenBuilder(): any;

    createBlob(ownerId: string, type: string, name: string, data: Uint8Array | Array<number>): Promise<{blobId: ?string, name: string, type: string}>;

    createTestBankAccount(balance: number, currency: string): Promise<Array<any>>;

    createTestBankAccountOauth(balance: number, currency: string): Promise<?OauthBankAuthorization>;

    createTransferToken(lifetimeAmount: number, currency: string): any;

    createTransferTokenBuilder(lifetimeAmount: number, currency: string): any;

    deleteAddress(addressId: string): Promise<void>;

    deleteMember(): Promise<void>;

    endorseToken(token: Token): Promise<TokenOperationResult>;

    firstAlias(): Promise<?Alias>;

    getAccessTokens(offset: string, limit: number): Promise<{data: Array<Token>, offset: ?string}>;

    getAccount(accountId: string): Promise<?Account>;

    getAccounts(): Promise<Array<Account>>;

    getActiveAccessToken(toMemberId: string): Promise<?Token>;

    getAddress(addressId: string): Promise<?AddressRecord>;

    getAddresses(): Promise<Array<AddressRecord>>;

    getBalance(accountId: string, keyLevel: string): Promise<{balance: ?Balance, status: ?string}>;

    getBalances(accountIds: Array<string>, keyLevel: string): Promise<?Array<{balance: ?Balance, status: ?string}>>;

    getBankInfo(bankId: string): Promise<?BankInfo>;

    getBlob(blobId: string): Promise<?Blob>;

    getBlockingCancelTokenFunction(token: Token | string): Promise<?() => void>;

    getDefaultAccount(): Promise<?Account>;

    getNotification(notificationId: string): Promise<?Notification>;

    getNotifications(offset: string, limit: number): Promise<{data: Array<Notification>, offset: ?string}>;

    getProfile(id: string): Promise<?Profile>;

    getProfilePicture(id: string, size: "SMALL" | "MEDIUM" | "LARGE" | "ORIGINAL"): Promise<?Blob>;

    getReceiptContact(): Promise<?ReceiptContact>;

    getSubscriber(subscriberId: string): Promise<?Subscriber>;

    getSubscribers(): Promise<Array<Subscriber>>;

    getTestBankNotification(subscriberId: string, notificationId: string): Promise<?Notification>;

    getTestBankNotifications(subscriberId: string): Promise<?Array<Notification>>;

    getToken(tokenId: string): Promise<?Token>;

    getTokenBlob(tokenId: string, blobId: string): Promise<?Blob>;

    getTransaction(accountId: string, transactionId: string, keyLevel: string): Promise<?Transaction>;

    getTransactions(accountId: string, offset: string, limit: number, keyLevel: string): Promise<{data: Array<Transaction>, offset: ?string}>;

    getTransfer(transferId: string): Promise<?Transfer>;

    getTransferTokens(offset: string, limit: number): Promise<{data: Array<Token>, offset: ?string}>;

    getTransfers(tokenId: string, offset: string, limit: number): Promise<{data: Array<Transfer>, offset: ?string}>;

    isDefaultAccount(accountId: string): Promise<boolean>;

    keys(): Promise<?Array<Key>>;

    linkAccounts(authorization: OauthBankAuthorization | any): Promise<?Array<Account>>;

    memberId(): ?string;

    redeemToken(
        token: Token,
        amount: ?number,
        currency: ?string,
        description: ?string,
        destinations?: Array<TransferEndpoint>,
        refId?: string
    ): Promise<?Transfer>;

    removeAlias(alias: Alias): Promise<void>;

    removeAliases(aliases: Array<Alias>): Promise<void>;

    removeKey(keyId: string): Promise<void>;

    removeKeys(keyIds: Array<string>): Promise<void>;

    replaceAccessToken(tokenToCancel: Token, newResources: Array<Resource>): Promise<?TokenOperationResult>;

    replaceAndEndorseAccessToken(tokenToCancel: Token, newResources: Array<Resource>): Promise<?TokenOperationResult>;

    setCustomerInitiated(): void;

    setDefaultAccount(accountId: string): Promise<?Account>;

    setProfile(profile: Profile): Promise<?Profile>;

    setProfilePicture(type: string, data: Uint8Array | Array<number>): Promise<void>;

    setReceiptContact(type?: "EMAIL", value: string): Promise<void>;

    signTokenRequestState(tokenId: string, state: string): Promise<?Signature>;

    storeTokenRequest(tokenRequest: any): Promise<?any>;

    subscribeToNotifications(handler?: string, handlerInstructions?: {}): Promise<?Subscriber>;

    triggerBalanceStepUpNotification(accountIds: Array<string>): Promise<?string>;

    triggerStepUpNotification(tokenId: string): Promise<?string>;

    triggerTransactionStepUpNotification(accountId: string, transactionId: string): Promise<?string>;

    unlinkAccounts(accountIds: Array<string>): Promise<void>;

    unsubscribeFromNotifications(subscriberId: string): Promise<void>;

    useAccessToken(accessTokenId: string): void;

    useDefaultRecoveryRule(): Promise<?RecoveryRule>;
}

declare class Blob {
    id: string;
    payload: any;
    static create({id: string, payload: any}): Blob;
}
declare export class Alias {
    type: string;
    value: string;
    realm: string;
    static create({type: string, value: string, realm?: string}): Alias;
}
declare class Key {
    id: string;
    publicKey: string; // base64url encoded
    level: string;
    algorithm: string;
    expiresAtMs: string;
    static create({id: string, publicKey: string, level: string, algorithm: string, expiresAtMs?: string}): Key;
}
declare class Signature {
    memberId: string;
    keyId: string;
    signature: string;
    static create({memberId: string, keyId: string, signature: string}): Signature;
}
declare export class Address {
    houseNumber: string;
    houseName: string;
    flats: string;
    conscriptionNumber: string;
    street: string;
    place: string;
    postCode: string;
    city: string;
    country: string; // ISO alpha-2 code
    full: string;
    hamlet: string;
    suburb: string;
    subdistrict: string;
    district: string;
    province: string;
    state: string;
    static create({
        houseNumber?: string,
        houseName?: string,
        flats?: string,
        conscriptionNumber?: string,
        street?: string,
        place?: string,
        postCode?: string,
        city?: string,
        country?: string,
        full?: string,
        hamlet?: string,
        suburb?: string,
        subdistrict?: string,
        district?: string,
        province?: string,
        state?: string,
    }): Address;
}
declare class Account {
    id: string;
    name: string;
    bankId: string;
    tags: Array<any>;
    isLocked: boolean;
    accountFeatures: any;
    lastCacheUpdateMs: string;
    nextCacheUpdateMs: string;
    static create({
        id: string,
        name: string,
        bankId: string,
        tags: Array<any>,
        isLocked: boolean,
        accountFeatures: any,
        lastCacheUpdateMs: string,
        nextCacheUpdateMs: string,
    }): Account;
}
declare class TokenPayload {
    version: string;
    refId: string;
    issuer: any;
    from: any;
    to: any;
    effectiveAtMs: string;
    expiresAtMs: string;
    endorseUntilMs: string;
    description: string;
    transfer: any;
    access: any;
    actingAs: any;
    receiptRequested: boolean;
    static create({
        version: string,
        refId: string,
        issuer: any,
        from: any,
        to: any,
        effectiveAtMs: string,
        expiresAtMs: string,
        endorseUntilMs: string,
        description: string,
        transfer?: any,
        access?: any,
        actingAs: any,
        receiptRequested: boolean,
    }): TokenPayload;
}
declare class TokenMember {
    id: string;
    username: string;
    alias: Alias;
    static create({id: string, username: string, alias: Alias}): TokenMember;
}
declare class Token {
    id: string;
    payload: TokenPayload;
    payloadSignatures: Array<any>;
    replaceByTokenId: string;
    tokenRequestId: string;
    static create({
        id: string,
        payload: TokenPayload,
        payloadSignatures: Array<any>,
        replaceByTokenId: string,
        tokenRequestId: string,
    }): Token;
}
declare class TokenOperationResult {
    token: Token;
    status: string;
    static create({token: Token, status: string}): TokenOperationResult;
}
declare export class Resource {
    allAddresses: ?{};
    allAccounts: ?{};
    allTransactions: ?{};
    allBalances: ?{};
    address: ?Address;
    account: ?Account;
    transactions: ?{accountId: string};
    balance: ?{accountId: string};
    allAccountsAtBank: ?{bankId: string};
    allTransactionsAtBank: ?{bankId: string};
    allBalancesAtBank: ?{bankId: string};
    static create({
        allAddresses?: {},
        allAccounts?: {},
        allTransactions?: {},
        allBalances?: {},
        address?: Address,
        account?: Account,
        transactions?: {accountId: string},
        balance?: {accountId: string},
        allAccountsAtBank?: {bankId: string},
        allTransactionsAtBank?: {bankId: string},
        allBalancesAtBank?: {bankId: string},
    }): Resource;
}
declare class Notification{
    id: string;
    subscriberId: string;
    content: any;
    status: string;
    static create({
        id: string,
        subscriberId: string,
        content: any,
        status: string,
    }): Notification;
}
declare class Bank {
    id: string;
    name: string;
    logoUri: string;
    fullLogoUri: string;
    supportsAppless: boolean;
    supportsInformation: boolean;
    requiresExternalAuth: boolean;
    supportsSendPayment: boolean;
    supportsReceivePayment: boolean;
    provider: string;
    country: string;
    identifier: string;
    static create({
        id: string,
        name: string,
        logoUri: string,
        fullLogoUri: string,
        supportsAppless: boolean,
        supportsInformation: boolean,
        requiresExternalAuth: boolean,
        supportsSendPayment: boolean,
        supportsReceivePayment: boolean,
        provider: string,
        country: string,
        identifier: string,
    }): Bank;
}
declare class BankInfo {
    linkingUri: string; // deprecated
    redirectUriRegex: string;
    bankLinkingUri: string;
    static create({linkingUri: string, redirectUriRegex: string, bankLinkingUri: string}): BankInfo;
}
declare class Paging {
    page: number;
    perPage: number;
    pageCount: number;
    totalCount: number;
    static create({page: number, perPage: number, pageCount: number, totalCount: number}): Paging;
}
declare class AddressRecord{
    id: string;
    name: string;
    address: Address;
    addressSignature: Signature;
    static create({id: string, name: string, address: Address, addressSignature: Signature}): AddressRecord;
}
declare class RecoveryRule {
    primaryAgent: string;
    secondaryAgents: Array<string>;
    static create({primaryAgent: string, secondaryAgents: Array<string>}): RecoveryRule;
}
declare class ReceiptContact {
    value: string;
    type: string;
    static create({value: string, type: string}): ReceiptContact;
}
declare export class Profile {
    displayNameFirst: string;
    displayNameLast: string;
    originalPictureId: string;
    smallPictureId: string;
    mediumPictureId: string;
    largePictureId: string;
    static create({
        displayNameFirst: string,
        displayNameLast: string,
        originalPictureId: string,
        smallPictureId: string,
        mediumPictureId: string,
        largePictureId: string,
    }): Profile;
}
declare class Subscriber {
    id: string;
    handler: string;
    handlerInstructions: any;
    static create({id: string, handler: string, handlerInstructions: any}): Subscriber;
}
declare export class TransferEndpoint {
    account: any;
    customerData: CustomerData;
    static create({account: any, customerData?: CustomerData}): TransferEndpoint;
}
declare class CustomerData {
    legalNames: Array<string>;
    address: Address;
    static create({legalNames: Array<string>, address?: Address}): CustomerData;
}
declare class Transfer {
    id: string;
    transactionId: string;
    createdAtMs: string;
    payload: any;
    payloadSignatures: Array<Signature>;
    status: any;
    orderId: string;
    method: any;
    static create({
        id: string,
        transactionId: string,
        createdAtMs: string,
        payload: any,
        payloadSignatures: Array<Signature>,
        status: any,
        orderId: string,
        method: any,
    }): Transfer;
}
declare class Balance {
    accountId: string;
    current: Money;
    available: Money;
    static create({accountId: string, current: Money, available: Money}): Balance;
}
declare class Transaction {
    id: string;
    type: string;
    status: string;
    amount: Money;
    description: string;
    tokenId: string;
    tokenTransferId: string;
    createdAtMs: string;
    metadata: any;
    static create({
        id: string;
        type: string;
        status: string;
        amount: Money;
        description: string;
        tokenId: string;
        tokenTransferId: string;
        createdAtMs: string;
        metadata: any;
    }): Transaction;
}
declare export class OauthBankAuthorization {
    bankId: string;
    accessToken: string;
    static create({bankId: string, accessToken: string}): OauthBankAuthorization;
}
declare class Money {
    currency: string;
    value: string;
    static create({currency: string, value: string}): Money;
}
